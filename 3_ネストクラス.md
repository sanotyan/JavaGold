# 3章 ネストクラス
3章はネストクラスについてです。  
一見複雑そうですが、基本的な振舞いは変数とほぼ同じことが理解できればそれほど難しくはありません。
## 2-1 ネストクラス
##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        InnerClass inner = new InnerClass();
        inner.privateMethod();
    }
    private class InnerClass {
        private void privateMethod() {
            System.out.println("inner");
        }
    }
}
```  
答え：InnerClassのインスタンス生成行でコンパイルエラーが発生する。  

非staticなネストクラスを特にインナークラスと呼びます。  
staticメソッドからインナークラスにアクセスすることはできません。  
staticメソッドから非staticな変数にアクセスできないのと同様です。  
コンパイルするには「new Main().new InnerClass();」というようにメインクラスのインスタンスを生成してからアクセスするようにします。
##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        new Outer().outerMethod();
    }
}
class Outer {
    public void outerMethod() {
        new Inner().innerMethod();
    }
    private class Inner {
        public static String val = "Inner";
        private void innerMethod() {
            System.out.println(val);
        }
    }
}
```  
答え：Innerクラスのvalの宣言行でコンパイルエラーが発生する。 
  
インナークラス内でstatic変数、メソッドは宣言できません。  
前問からもわかるようにインナークラスにアクセスするには外側のクラスのインスタンスを生成する必要があります。  
static領域はアプリケーション実行時に生成されますが、その時点ではOuterクラスのインスタンスが生成されておらず、Innerクラスにアクセスできないためコンパイルエラーとなります。

##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        new Outer().outerMethod();
        new Outer.Inner().innerMethod();
    }
}
class Outer {
    public void outerMethod() {
        new Inner().innerMethod();
    }
    public static class Inner {
        public void innerMethod() {
            System.out.print("static inner");
        }
    }
}
```
答え：static innerstatic inner  

static変数がそうであるように、staticなネストクラスには外側のクラスをインスタンス化しなくてもアクセスすることができます。  
その際、[外側のクラス名].[内側のクラス名]という記述でアクセスします。  
innerMethodメソッドは非staticなので、Innerクラスをインスタンス化しないと呼び出すことができないことに注意しましょう。  

##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        new Outer().outerMethod();
    }
}
class Outer {
    private String val = "Outer";
    public void outerMethod() {
        Inner in = new Inner();
        System.out.print(in.val);
        in.innerMethod();
    }
    private class Inner {
        private String val = "Inner";
        private void innerMethod() {
            System.out.print(val);
            System.out.print(Outer.this.val);
        }
    }
}
```
答え：InnerInnerOuter  

外側のクラスからprivateネストクラスにアクセスできるだけでなく、ネストクラスのprivateメンバにもアクセスできます。  
また、ネストクラスから外側のprivateメンバにもアクセスできます。  
ネストクラスから外側のクラスのインスタンスにアクセスする場合は、[外側のクラス名].thisという記述を用います。  

## 2-2 ローカルクラス
##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        String val = "Main";
        Local l = new Local();
        l.sayVal();
        class Local {
            private String val = "Local";
            private void sayVal() {
                System.out.println(val);
            }
        }
    }
}
```
答え：Localクラスのインスタンス生成行でコンパイルエラーが発生する。  

ローカルクラスは実行時に読み込まれるので使用する前に宣言する必要があります。  
考え方はローカル変数と同様です。  
この問では宣言前前にインスタンス化しようとしているため、コンパイルエラーが発生しています。  

##### 問.以下のコードを実行した結果を述べよ。
```java
class Main {
    public static void main(String[] args) {
        String val="initialize";
        val = "Main";
        class Local {
            private void sayVal() {
                System.out.println(val);
            }
        }
        Local l = new Local();
        l.sayVal();
    }
}
```

### 2-2-3 おまけ
問.以下のコードを実行した結果を述べよ。
```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        String header = "";
        header = "word:";
        List<String> strings = Arrays.asList("a","b","c");
        strings.forEach(s -> System.out.println(header + s));
    }
}
```
[戻る](https://github.com/sanotyan1202/JavaGold)
